/*
 * Copyright (C) 2015-2019 akha, a.k.a. Alexander Kharitonov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package akha.yakhont.loader.wrapper;

import akha.yakhont.Core;
import akha.yakhont.Core.BaseDialog;
import akha.yakhont.Core.Utils;
import akha.yakhont.Core.Utils.ViewHelper;
import akha.yakhont.CoreLogger;
import akha.yakhont.CoreLogger.Level;
// ProGuard issue
// import akha.yakhont.R;
import akha.yakhont.adapter.BaseCacheAdapter;
import akha.yakhont.adapter.BaseRecyclerViewAdapter;
import akha.yakhont.adapter.BaseRecyclerViewAdapter.PagingRecyclerViewAdapter;
import akha.yakhont.loader.BaseConverter;
import akha.yakhont.loader.BaseLiveData.LiveDataDialog;
import akha.yakhont.loader.BaseLiveData.LiveDataDialog.Progress;
import akha.yakhont.loader.BaseLiveData.Requester;
import akha.yakhont.loader.BaseViewModel;
import akha.yakhont.loader.BaseViewModel.PagingViewModel;
import akha.yakhont.loader.wrapper.BaseResponseLoaderWrapper.CoreLoad;
import akha.yakhont.loader.wrapper.BaseResponseLoaderWrapper.CoreLoadExtendedBuilder;
import akha.yakhont.technology.retrofit.Retrofit2LoaderWrapper;
import akha.yakhont.technology.retrofit.Retrofit2LoaderWrapper.Retrofit2LoaderBuilder;

import android.app.Activity;
import android.content.ContentValues;
import android.database.Cursor;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;
import android.view.View;
import android.widget.ListAdapter;

import androidx.annotation.IdRes;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.WorkerThread;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Observer;
import androidx.lifecycle.ViewModelProvider;
import androidx.lifecycle.ViewModelStore;
import androidx.paging.DataSource;
import androidx.paging.PagedListAdapter;
import androidx.recyclerview.widget.RecyclerView.Adapter;
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout.OnRefreshListener;

import java.lang.ref.WeakReference;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * The <code>BaseLoaderWrapper</code> class is a wrapper for data loading classes like {@link BaseViewModel}.
 * It's designed to be a root class for standalone, independent, self-sufficient data loading components
 * (hiding low-level implementation details and data loading classes's related boilerplate code).
 * Most implementations should not use <code>BaseLoaderWrapper</code> directly, but instead utilise
 * {@link Retrofit2LoaderWrapper} or {@link Retrofit2LoaderBuilder}.
 *
 * @param <D>
 *        The type of data
 *
 * @see BaseResponseLoaderWrapper
 * @see BaseViewModel
 *
 * @author akha
 */
@SuppressWarnings("JavadocReference")
public abstract class BaseLoaderWrapper<D> {

    private static final String                             FORMAT_INFO                 = "BaseLoaderWrapper: %s";

    private        final ViewModelStore                     mViewModelStore;

    private        final String                             mLoaderId;
    private        final boolean                            mLoaderIdAutoGenerated;

    private              SwipeToRefreshWrapper              mSwipeToRefreshWrapper;
    private              Runnable                           mSwipeToRefreshCallback;
    private              boolean                            mSwipeToRefresh;

    private              CountDownLatch                     mCountDownLatch;
    private              D                                  mData;

    private static final Random                             RANDOM                      = new Random();

    private              Type                               mType;

    private              Callable<Progress>                 mProgress;

    private              Callable<? extends BaseViewModel<D>>
                                                            mBaseViewModel;
    private              String                             mBaseViewModelKey;

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected            LoadParameters                     mParameters;

    /**
     * The API for data conversion.
     *
     * @param <D>
     *        The type of data
     */
    public interface ConverterHelper<D> {

        /**
         * Converts serialized data to object.
         *
         * @param string
         *        The additional information
         *
         * @param data
         *        The serialized data
         *
         * @return  The data object
         */
        D get(String string, byte[] data);
    }

    /**
     * Allows to get instance of {@link ConverterHelper}.
     *
     * @param <D>
     *        The type of data
     */
    public interface ConverterGetter<D> {

        /**
         * Returns instance of {@link ConverterHelper}.
         *
         * @param type
         *        The data type
         *
         * @return  The ConverterHelper
         */
        @SuppressWarnings("unused")
        ConverterHelper<D> get(Type type);
    }

    /**
     * The API to convert data.
     *
     * @param <D>
     *        The type of data
     *
     * @see BaseConverter
     */
    public interface Converter<D> {

        /**
         * Sets {@code ConverterGetter}.
         *
         * @param getter
         *        The {@code ConverterGetter}
         */
        void setConverterGetter(ConverterGetter<D> getter);

        /**
         * Returns the data to store in cache.
         *
         * @param string
         *        The string data
         *
         * @param bytes
         *        The bytes data
         *
         * @param cls
         *        The type of data
         *
         * @return  The ContentValues
         */
        ContentValues getValues(String string, byte[] bytes, Class cls);

        /**
         * Converts cursor to data.
         *
         * @param cursor
         *        The Cursor
         *
         * @return  The data
         */
        D getData(Cursor cursor);

        /**
         * Returns the type of last converted data.
         *
         * @return  The type of data (or null)
         */
        Type getType();
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected static boolean isLoaderIdAutoGenerated(final String loaderId) {
        return loaderId == null;
    }

    /**
     * Initialises a newly created {@code BaseLoaderWrapper} object.
     *
     * @param activity
     *        The Activity
     *
     * @param loaderId
     *        The loader ID (or null)
     */
    protected BaseLoaderWrapper(@NonNull final Activity activity, final String loaderId) {
        this(activity, loaderId, isLoaderIdAutoGenerated(loaderId));
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected BaseLoaderWrapper(@NonNull final Activity activity, final String loaderId,
                                final boolean  loaderIdAutoGenerated) {
        this(BaseViewModel.getViewModelStore(activity), loaderId, loaderIdAutoGenerated);
    }

    /**
     * Initialises a newly created {@code BaseLoaderWrapper} object.
     *
     * @param fragment
     *        The Fragment
     *
     * @param loaderId
     *        The loader ID (or null)
     */
    protected BaseLoaderWrapper(@NonNull final Fragment fragment, final String loaderId) {
        this(fragment, loaderId, isLoaderIdAutoGenerated(loaderId));
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected BaseLoaderWrapper(@NonNull final Fragment fragment, final String loaderId,
                                         final boolean  loaderIdAutoGenerated) {
        this(BaseViewModel.getViewModelStore(fragment), loaderId, loaderIdAutoGenerated);
    }

    /**
     * Initialises a newly created {@code BaseLoaderWrapper} object.
     *
     * @param loaderId
     *        The loader ID (or null)
     */
    protected BaseLoaderWrapper(final String loaderId) {
        this(loaderId, isLoaderIdAutoGenerated(loaderId));
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected BaseLoaderWrapper(final String loaderId, final boolean loaderIdAutoGenerated) {
        this(BaseViewModel.getViewModelStore((Activity) null), loaderId, loaderIdAutoGenerated);
    }

    /**
     * Initialises a newly created {@code BaseLoaderWrapper} object.
     *
     * @param viewModelStore
     *        The ViewModelStore
     *
     * @param loaderId
     *        The loader ID (or null)
     */
    protected BaseLoaderWrapper(@NonNull final ViewModelStore viewModelStore, final String loaderId) {
        this(viewModelStore, loaderId, isLoaderIdAutoGenerated(loaderId));
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected BaseLoaderWrapper(@NonNull final ViewModelStore viewModelStore,
                                final String loaderId, final boolean loaderIdAutoGenerated) {

        mViewModelStore             = viewModelStore;

        mLoaderIdAutoGenerated      = loaderId == null || loaderIdAutoGenerated;
        mLoaderId                   = loaderId != null ? loaderId: generateLoaderId(null);

        if (mLoaderIdAutoGenerated) CoreLogger.log("auto generated id " + loaderId);
    }

    /**
     * Sets component to display progress.
     *
     * @param progress
     *        The progress component
     *
     * @return  This {@code BaseLoaderWrapper} object
     */
    @SuppressWarnings({"WeakerAccess", "UnusedReturnValue"})
    public BaseLoaderWrapper<D> setProgress(final Callable<Progress> progress) {
        mProgress              = progress;
        return this;
    }

    /**
     * Sets the {@code BaseViewModel} component.
     *
     * @param baseViewModel
     *        The {@code BaseViewModel} component
     *
     * @return  This {@code BaseLoaderWrapper} object
     */
    @SuppressWarnings({"WeakerAccess", "UnusedReturnValue"})
    public BaseLoaderWrapper<D> setBaseViewModel(final Callable<? extends BaseViewModel<D>> baseViewModel) {
        if (baseViewModel != null && mProgress != null)
            CoreLogger.logWarning("you set BaseViewModel; already set Callable<Progress> " +
                    "(via setProgress() call) will be ignored");
        mBaseViewModel         = baseViewModel;
        return this;
    }

    /**
     * Sets the {@code BaseViewModel} key.
     *
     * @param key
     *        The {@code BaseViewModel} key (please refer to {@link ViewModelProvider#get(String, Class)})
     *
     * @return  This {@code BaseLoaderWrapper} object
     */
    @SuppressWarnings({"WeakerAccess", "UnusedReturnValue"})
    public BaseLoaderWrapper<D> setBaseViewModelKey(final String key) {
        mBaseViewModelKey       = key;
        return this;
    }

    /**
     * Sets the "swipe-to-refresh" callback which will be called just before data loading process if
     * it was triggered this way.
     *
     * @param callback
     *        The {@code Runnable} callback
     *
     * @return  This {@code BaseLoaderWrapper} object
     */
    @SuppressWarnings({"WeakerAccess", "UnusedReturnValue"})
    public BaseLoaderWrapper<D> setSwipeToRefreshCallback(final Runnable callback) {
        mSwipeToRefreshCallback = callback;
        return this;
    }

    /**
     * Sets the type of data.
     *
     * @param type
     *        The data type
     *
     * @return  This {@code BaseLoaderWrapper} object
     *
     * @see CoreLoadExtendedBuilder#setType
     */
    @SuppressWarnings({"WeakerAccess", "UnusedReturnValue"})
    public BaseLoaderWrapper<D> setType(final Type type) {
        mType                   = type;
        return this;
    }

    /**
     * Returns the type of data (if was set).
     *
     * @return  The data type
     *
     * @see #setType(Type) setType()
     */
    @SuppressWarnings("WeakerAccess")
    public Type getType() {
        return mType;
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "UnusedReturnValue"})
    protected BaseLoaderWrapper<D> setTypeIfNotSet(@NonNull final Type type) {
        if (mType == null)
            mType = type;
        else if (!mType.equals(type))
            CoreLogger.logWarning("setTypeIfNotSet: type " + type + " will be ignored");
        return this;
    }

    /**
     * Sets "swipe refresh" component.
     *
     * @param swipeToRefreshWrapper
     *        The component
     *
     * @return  This {@code BaseLoaderWrapper} object
     */
    @NonNull
    @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
    public BaseLoaderWrapper<D> setSwipeToRefreshWrapper(final SwipeToRefreshWrapper swipeToRefreshWrapper) {
        mSwipeToRefreshWrapper = swipeToRefreshWrapper;
        return this;
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected static String generateLoaderId(final String id) {
        return id != null ? id: String.valueOf(RANDOM.nextInt(Integer.MAX_VALUE));
    }

    /**
     * Returns the loader ID.
     *
     * @return  The loader ID
     */
    @SuppressWarnings("WeakerAccess")
    public String getLoaderId() {
        return mLoaderId;
    }

    /**
     * Indicates whether the loader ID was auto generated or not.
     *
     * @return  {@code true} if the loader ID was auto generated, {@code false} otherwise
     */
    @SuppressWarnings({"WeakerAccess", "unused"})
    public boolean isAutoGeneratedId() {
        return mLoaderIdAutoGenerated;
    }

    /**
     * Tries to find similar loader (based on ID) in the given collection.
     *
     * @param loaders
     *        The loaders collection
     *
     * @return  The {@code BaseLoaderWrapper} object or null (if not found)
     */
    @SuppressWarnings("WeakerAccess")
    public BaseLoaderWrapper findLoader(final Collection<BaseLoaderWrapper<?>> loaders) {
        for (final BaseLoaderWrapper baseLoaderWrapper: loaders)
            if (baseLoaderWrapper.mLoaderId.equals(mLoaderId)) {
                CoreLogger.log("found loader with id " + mLoaderId);
                return baseLoaderWrapper;
            }
        CoreLogger.log("can't find loader with id " + mLoaderId);
        return null;
    }

    /**
     * Please refer to the base method description.
     */
    @NonNull
    @Override
    public String toString() {
        return String.format(Utils.getLocale(), FORMAT_INFO, mLoaderId);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Starts data loading.
     *
     * @param loaders
     *        The loaders
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if at least one loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("unused")
    public static boolean start(final Collection<BaseLoaderWrapper<?>> loaders, final LoadParameters parameters) {
        return start(null, loaders, parameters);
    }

    /**
     * Starts data loading.
     *
     * @param activity
     *        The Activity
     *
     * @param loaders
     *        The loaders
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if at least one loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    public static boolean start(final Activity activity, final Collection<BaseLoaderWrapper<?>> loaders,
                                final LoadParameters parameters) {
        if (!checkEmpty(Level.ERROR, loaders)) return false;

        if (parameters == null || parameters.getLoaderId() == null) {
            boolean result = true;
            for (final BaseLoaderWrapper loader: loaders)
                if (!loader.start(activity, parameters)) result = false;
            return result;
        }
        else {
            final String id = parameters.getLoaderId();
            for (final BaseLoaderWrapper loader: loaders)
                if (loader.getLoaderId().equals(id))
                    return loader.start(activity, parameters);
            CoreLogger.logError("invalid loader ID: " + id);
            return false;
        }
    }

    /**
     * Starts data loading with default parameters.
     * <p>
     * If {@code savedInstanceState} is not null, loaders will be fully prepared
     * but real data loading will not start.
     *
     * @param savedInstanceState
     *        Please refer to {@link Activity#onCreate(Bundle)}
     *
     * @return  {@code false} if loader failed to start, {@code true} otherwise
     *
     * @see     LoadParameters#NO_LOAD
     */
    @SuppressWarnings("unused")
    public boolean start(final Bundle savedInstanceState) {
        return start(getLoadParameters(savedInstanceState));
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    public static LoadParameters getLoadParameters(final Bundle savedInstanceState) {
        return savedInstanceState == null ? new LoadParameters(): LoadParameters.NO_LOAD;
    }

    /**
     * Starts data loading.
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    public boolean start(final LoadParameters parameters) {
        return start((Activity) null, parameters);
    }

    /**
     * Starts data loading.
     *
     * @param activity
     *        The Activity
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    public boolean start(final Activity activity, final LoadParameters parameters) {
        final boolean result = startHelper(activity, parameters);
        CoreLogger.log(result ? CoreLogger.getDefaultLevel(): Level.ERROR, "start loading result: " + result);
        return result;
    }

    private boolean startHelper(final Activity activity, final LoadParameters parameters) {
        if (parameters == null)
            return startLoading(activity, null);

        if (parameters.getSync())
            return startSync(activity, parameters) != null;

        if (!parameters.checkArguments()) return false;

        final String id = parameters.getLoaderId();
        if (id != null && !mLoaderId.equals(id)) {
            CoreLogger.logError("invalid loader ID: " + id + " (required " + mLoaderId + " or null)");
            return false;
        }

        return startLoading(activity, parameters);
    }

    /**
     * Returns database cache table name (or null, if cache disabled).
     *
     * @return  The cache table name
     */
    @SuppressWarnings("WeakerAccess")
    protected abstract String getTableName();

    /**
     * Returns database cache table description (or null, if cache disabled).
     *
     * @return  The cache table description
     */
    @SuppressWarnings("WeakerAccess")
    protected abstract String getTableDescription();

    /**
     * Returns the {@link ListAdapter} associated with the given loader.
     *
     * @return  The {@link ListAdapter}
     */
    @SuppressWarnings("unused")
    public abstract BaseCacheAdapter       <?, ?, ?, ?> getListAdapter();

    /**
     * Returns the {@link Adapter RecyclerView.Adapter} associated with the given loader.
     *
     * @return  The {@link Adapter}
     */
    @SuppressWarnings("unused")
    public abstract BaseRecyclerViewAdapter<?, ?, ?, ?> getRecyclerViewAdapter();

    /**
     * Returns the {@link PagedListAdapter} associated with the given loader.
     *
     * @return  The {@link PagedListAdapter}
     */
    @SuppressWarnings("unused")
    public abstract PagingRecyclerViewAdapter<?, ?, ?> getPagingAdapter();

    /**
     * Returns the data loading progress GUI component.
     *
     * @return  The data loading progress GUI
     */
    @SuppressWarnings("WeakerAccess")
    protected Progress getProgress() {
        try {
            return mProgress == null ? null: mProgress.call();
        }
        catch (Exception exception) {
            CoreLogger.log(exception);
            return null;
        }
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected BaseViewModel<D> getBaseViewModel(         final Activity         activity,
                                                @NonNull final ViewModelStore   store,
                                                         final String           key,
                                                         final String           tableName,
                                                @NonNull final Requester<D>     requester,
                                                @NonNull final Observer <D>     observer) {
        return new BaseViewModel.Builder<>(observer)
                .setViewModelStore(store)
                .setActivity(activity)
                .setKey(key)
                .setTableName(tableName)
                .setRequester(requester)
                .create();
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected BaseViewModel<D> getBaseViewModel(final Activity activity) {
        CoreLogger.log("about to create ViewModel");
        try {
            if (mBaseViewModel != null) return mBaseViewModel.call();
        }
        catch (Exception exception) {
            CoreLogger.log(exception);
            return null;
        }

        final RequesterHelper requesterHelper = new RequesterHelper();

        @SuppressWarnings({"Convert2Lambda", "Anonymous2MethodRef"})
        final BaseViewModel<D> baseViewModel = getBaseViewModel(activity, mViewModelStore,
                getKey(), getTableName(), requesterHelper, new Observer<D>() {
                    @Override
                    public void onChanged(@Nullable D data) {
                        onLoadFinished(data);
                    }
                });

        requesterHelper.mBaseViewModel = new WeakReference<>(baseViewModel);

        final Progress progress = getProgress();
        if (progress != null) {
            final BaseDialog baseDialog = baseViewModel.getData().getBaseDialog();

            if (baseDialog instanceof LiveDataDialog)
                ((LiveDataDialog) baseDialog).setProgress(progress);
            else
                CoreLogger.logError("can't set progress for baseDialog 'cause it's not " +
                        "an instance of LiveDataDialog but " + CoreLogger.getDescription(baseDialog));
        }

        return baseViewModel;
    }

    private String getKey() {
        return mBaseViewModelKey != null ? mBaseViewModelKey: mLoaderId;
    }

    private class RequesterHelper implements Requester<D> {

        private          WeakReference<BaseViewModel<D>>    mBaseViewModel;

        @Override
        public void cancel() {
            final BaseViewModel<D> model = getBaseViewModel(true);
            if (model == null)
                CoreLogger.logWarning("cancel request: model == null, loader ID: " + mLoaderId);
            else {
                final List<CoreLoad<?, ?>> coreLoads = model.getCoreLoads();
                if (coreLoads != null && coreLoads.size() > 0) {
                    for (final CoreLoad<?, ?> coreLoad: coreLoads)
                        coreLoad.cancelLoading(null);
                    return;
                }
                else
                    CoreLogger.logWarning("cancel request: empty loaders list, loader ID: " + mLoaderId);
            }
            CoreLogger.logWarning("call cancel request without CoreLoad, loader ID: " + mLoaderId);
            cancelRequest(CoreLogger.getDefaultLevel());
        }

        @Override
        public D call() {
            D result = null;
            try {
                final BaseViewModel<D> baseViewModel = getBaseViewModel(true);
                if (baseViewModel == null)
                    CoreLogger.logError("can't make request 'cause baseViewModel == null, loader ID: " + mLoaderId);
                else
                    result = makeRequest(baseViewModel);
            }
            catch (Exception exception) {
                CoreLogger.log("loader ID: " + mLoaderId, exception);
            }
            return result;
        }

        private BaseViewModel<D> getBaseViewModel(
                @SuppressWarnings("SameParameterValue") final boolean isError) {
            BaseViewModel<D> result = null;

            if (mBaseViewModel == null)     // should never happen
                CoreLogger.log(isError ? Level.ERROR: CoreLogger.getDefaultLevel(),
                        "mBaseViewModel == null, loader ID: " + mLoaderId);
            else {
                result = mBaseViewModel.get();

                if (result == null)         // should never happen
                    CoreLogger.log(isError ? Level.ERROR: CoreLogger.getDefaultLevel(),
                            "baseViewModel == null, loader ID: " + mLoaderId);
            }
            return result;
        }
    }

    /**
     * Called when data loading process completes.
     *
     * @param data
     *        The data loaded
     */
    @SuppressWarnings("WeakerAccess")
    protected void onLoadFinished(final D data) {
        if (CoreLogger.isFullInfo())
            CoreLogger.log("loader ID: " + mLoaderId + ", data: " + data);

        mData = data;

        if (mParameters == null)                // should never happen
            CoreLogger.logError("parameters == null");
        else if (mParameters.getNoLoad())       // should never happen too
            CoreLogger.logError("parameters.getNoLoad() == true");

        handleSync();
        stopRefreshing();
    }

    /**
     * Makes data loading request.
     *
     * @param baseViewModel
     *        The BaseViewModel
     */
    @SuppressWarnings("SameReturnValue")
    protected abstract D makeRequest(@NonNull final BaseViewModel<D> baseViewModel);

    /** @exclude */ @SuppressWarnings({"JavaDoc", "UnusedReturnValue"})
    protected boolean cancelRequest(@NonNull final Level level) {
        CoreLogger.log(level, "request cancelling is not supported");
        return false;
    }

    /**
     * Finds ViewModel (if any) for the given Activity.
     *
     * @param activity
     *        The Activity
     *
     * @return  The ViewModel (or null)
     */
    @SuppressWarnings("WeakerAccess")
    public BaseViewModel<?> findViewModel(Activity activity) {
        if (activity == null) activity = Utils.getCurrentActivity();
        return findViewModel(getModels(activity));
    }

    private BaseViewModel<?> findViewModel(final Set<Map.Entry<String,
            WeakReference<? extends BaseViewModel<?>>>> viewModels) {

        if (viewModels == null) {
            CoreLogger.log("ViewModels == null");
            return null;
        }

        for (final Map.Entry<String, WeakReference<? extends BaseViewModel<?>>> entry: viewModels)
            if (entry.getKey().equals(mLoaderId)) {
                final BaseViewModel<?> model = entry.getValue().get();
                if (model != null) return model;

                CoreLogger.logWarning("model == null, id: " + mLoaderId);
                break;
            }

        return null;
    }

    /**
     * Gets the data loading status.
     *
     * @return  {@code true} if data loading is in progress, {@code false} otherwise
     */
    @SuppressWarnings("unused")
    public boolean isLoading() {
        final BaseViewModel<?> model = findViewModel(getModels(null));
        return model != null && model.getData().isLoading();
    }

    private Set<Map.Entry<String, WeakReference<? extends BaseViewModel<?>>>> getModels(Activity activity) {
        if (activity == null) activity = Utils.getCurrentActivity();

        final Set<Map.Entry<String, WeakReference<? extends BaseViewModel<?>>>> set    =
                BaseViewModel.getViewModels(activity);
        final Set<Map.Entry<String, WeakReference<? extends BaseViewModel<?>>>> result =
                set != null && !set.isEmpty() ? set: BaseViewModel.getViewModels(mViewModelStore);

        if (result == null) CoreLogger.log("getModels() returns null");
        return result;
    }

    private boolean startLoading(Activity activity, LoadParameters parameters) {

        if (activity   == null) activity   = Utils.getCurrentActivity();
        if (parameters == null) parameters = new LoadParameters();

        BaseViewModel<?>   model = findViewModel(getModels(activity));
        if (model == null) model = getBaseViewModel(activity);

        if (model != null) {
            if (!parameters.getNoLoad()) {
                if (mSwipeToRefresh) {
                    if (!parameters.getPullToRefresh())
                        parameters = new LoadParameters(parameters, true);
                    mSwipeToRefresh = false;
                }

                mData       = null;
                mParameters = parameters;

                if (parameters.getPullToRefresh() && mSwipeToRefreshCallback != null)
                    Utils.safeRunnableRun(mSwipeToRefreshCallback);

                model.getData().makeRequest(activity, LiveDataDialog.getInfoText(
                        getTableDescription()), null, parameters);
            }
            return true;
        }

        // should never happen
        CoreLogger.logError("there's no model with id " + mLoaderId);
        return false;
    }

    /**
     * Invalidates paging DataSource (mainly for swipe-to-refresh).
     *
     * @param activity
     *        The Activity
     *
     * @return  {@code false} if no DataSources to invalidate, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    public boolean invalidateDataSource(Activity activity) {
        final BaseViewModel<?> model = findViewModel(activity);
        if (!(model instanceof PagingViewModel)) return false;

        final boolean result = ((PagingViewModel) model).invalidateDataSource();
        if (!result) CoreLogger.logWarning("can't invalidate DataSource");
        return result;
    }

    private void stopRefreshing() {
        if (mSwipeToRefreshWrapper != null) mSwipeToRefreshWrapper.stopRefreshing();
    }

    private void handleSync() {
        if (mCountDownLatch == null) return;

        mCountDownLatch.countDown();
        mCountDownLatch = null;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Starts data loading in synchronous mode with default parameters.
     *
     * @param savedInstanceState
     *        Please refer to {@link Activity#onCreate(Bundle)}
     *
     * @return  {@code false} if loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("unused")
    public D startSync(final Bundle savedInstanceState) {
        return startSync(getLoadParameters(savedInstanceState));
    }

    /**
     * Starts data loading in synchronous mode.
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    @WorkerThread
    public D startSync(final LoadParameters parameters) {
        return startSync((Activity) null, parameters);
    }

    /**
     * Starts data loading in synchronous mode.
     *
     * @param activity
     *        The Activity
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    @WorkerThread
    public D startSync(final Activity activity, final LoadParameters parameters) {
        final boolean result = startSync(activity, Collections.singletonList(this), parameters);
        return result ? mData: null;
    }

    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    private static boolean checkEmpty(@SuppressWarnings("SameParameterValue") @NonNull final Level level,
                                      final Collection<BaseLoaderWrapper<?>> loaders) {
        final boolean empty = loaders == null || loaders.isEmpty();
        if (empty)
            CoreLogger.log(level, "no loaders in collection");
        else
            CoreLogger.log("loaders list size: " + loaders.size());
        return !empty;
    }

    /**
     * Starts data loading in synchronous mode.
     *
     * @param loaders
     *        The loaders
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if at least one loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings({"WeakerAccess", "unused"})
    @WorkerThread
    public static boolean startSync(final Collection<BaseLoaderWrapper<?>> loaders,
                                    final LoadParameters                   parameters) {
        return startSync(null, loaders, parameters);
    }

    /**
     * Starts data loading in synchronous mode.
     *
     * @param activity
     *        The Activity
     *
     * @param loaders
     *        The loaders
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if at least one loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    @WorkerThread
    public static boolean startSync(final Activity activity, final Collection<BaseLoaderWrapper<?>> loaders,
                                    final LoadParameters parameters) {
        if (parameters != null && !parameters.checkArguments()) return false;

        if (parameters != null && !parameters.getSync()) {
            CoreLogger.logError("invalid parameter sync: false");
            return false;
        }
        if (Utils.isCurrentThreadMain()) {
            CoreLogger.logError("not allowed to run from the main thread");
            return false;
        }

        if (!checkEmpty(Level.ERROR, loaders)) return false;

        if (parameters != null && parameters.getLoaderId() != null) {
            final String id = parameters.getLoaderId();
            boolean found = false;
            for (final BaseLoaderWrapper loader: loaders)
                if (loader.mLoaderId.equals(id)) {
                    found = true;
                    break;
                }
            if (!found) {
                CoreLogger.logError("no such loader ID: " + id);
                return false;
            }
        }

        final CountDownLatch countDownLatch = new CountDownLatch(
                parameters != null && parameters.getLoaderId() != null ? 1: loaders.size());

        for (final BaseLoaderWrapper loader: loaders)
            if (checkId(parameters, loader.mLoaderId))
                loader.setCountDownLatch(countDownLatch);

        final boolean[] result = new boolean[] {true};
        //noinspection Convert2Lambda
        Utils.runInBackground(new Runnable() {
            @Override
            public void run() {
                for (final BaseLoaderWrapper loader: loaders)
                    if (checkId(parameters, loader.mLoaderId))
                        if (!loader.start(activity, parameters)) result[0] = false;
            }
        });

        await(countDownLatch);

        for (final BaseLoaderWrapper loader: loaders)
            if (checkId(parameters, loader.mLoaderId))
                loader.setCountDownLatch(null);

        CoreLogger.log("completed");
        return result[0];
    }

    private static boolean checkId(final LoadParameters parameters, final String id) {
        if (parameters == null) return true;
        final String idParam = parameters.getLoaderId();
        return idParam == null || id.equals(idParam);
    }

    private static void await(final CountDownLatch countDownLatch) {
        if (countDownLatch == null) return;
        try {
            countDownLatch.await();
        }
        catch (InterruptedException exception) {
            CoreLogger.log(exception);
        }
    }

    @SuppressWarnings("UnusedReturnValue")
    private BaseLoaderWrapper<D> setCountDownLatch(final CountDownLatch countDownLatch) {
        mCountDownLatch = countDownLatch;
        return this;
    }

    /**
     * Returns the loaded data.
     *
     * @return  The loaded data
     */
    @SuppressWarnings("unused")
    public D getResult() {
        return mData;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * The <code>SwipeToRefreshWrapper</code> class is intended to support "swipe-to-refresh" feature
     * (in case of {@link PagedListAdapter} the {@link DataSource#invalidate} method will be called).
     * To enable swipe-to-refresh, activity (or fragment) should contain {@link SwipeRefreshLayout}
     * and register it via one of the methods provided. For example:
     *
     * <p><pre style="background-color: silver; border: thin solid black;">
     * import akha.yakhont.loader.wrapper.BaseResponseLoaderWrapper.CoreLoad;
     *
     * public class YourFragment extends Fragment {
     *
     *     &#064;Override
     *     public void onActivityCreated(Bundle savedInstanceState) {
     *         super.onActivityCreated(savedInstanceState);
     *
     *         CoreLoad coreLoad = ...
     *
     *         SwipeToRefreshWrapper.register(R.id.swipeContainer, coreLoad);
     *     }
     * }
     * </pre>
     *
     * And in the layout XML:
     *
     * <p><pre style="background-color: silver; border: thin solid black;">
     * &lt;android.support.v4.widget.SwipeRefreshLayout
     *     android:id="&#064;+id/swipeContainer"
     *     ... &gt;
     *
     *     &lt;androidx.recyclerview.widget.RecyclerView ... /&gt;
     *
     * &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;
     * </pre>
     *
     * @see SwipeRefreshLayout
     */
    @SuppressWarnings("WeakerAccess")
    public static class SwipeToRefreshWrapper<D> {

        @IdRes
        private static final int                            ID_SWIPE_LAYOUT             =
                akha.yakhont.R.id.yakhont_swipe_refresh_layout;

        private final OnRefreshListenerHelper               mOnRefreshListener;

        private final WeakReference<SwipeRefreshLayout>     mSwipeRefreshLayout;

        @SuppressWarnings("unused")
        private SwipeToRefreshWrapper(@NonNull final OnRefreshListenerHelper           onRefreshListener,
                                      @NonNull final WeakReference<SwipeRefreshLayout> swipeRefreshLayout) {
            mOnRefreshListener  = onRefreshListener;
            mSwipeRefreshLayout = swipeRefreshLayout;
        }

        /**
         * Enables "swipe-to-refresh" feature for the current activity.
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         *
         * @param coreLoad
         *        The {@code CoreLoad} component
         *
         * @param <E>
         *        The type of error (if any)
         *
         * @param <D>
         *        The type of data to load
         */
        @SuppressWarnings("unused")
        public static <E, D> boolean register(@IdRes final int resId, final CoreLoad<E, D> coreLoad) {
            return register(findSwipeRefreshLayout(null, resId), coreLoad);
        }

        /**
         * Enables "swipe-to-refresh" feature for the current activity.
         *
         * @param swipeRefreshLayout
         *        The {@code SwipeRefreshLayout}
         *
         * @param coreLoad
         *        The {@code CoreLoad} component
         *
         * @param <E>
         *        The type of error (if any)
         *
         * @param <D>
         *        The type of data to load
         */
        public static <E, D> boolean register(final SwipeRefreshLayout swipeRefreshLayout,
                                              final CoreLoad<E, D>     coreLoad) {
            if (coreLoad == null) {
                CoreLogger.logError("can't register SwipeToRefresh, coreLoad == null");
                return false;
            }
            return register(null, swipeRefreshLayout, coreLoad.getLoaders());
        }

        /**
         * Enables "swipe-to-refresh" feature for the given activity.
         *
         * @param activity
         *        The Activity
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         *
         * @param baseLoaderWrappers
         *        The {@code BaseLoaderWrapper}'s collection associated with the given activity
         */
        @SuppressWarnings("unused")
        public static boolean register(final Activity activity, @IdRes final int resId,
                                       final Collection<BaseLoaderWrapper<?>>    baseLoaderWrappers) {
            return register(activity, findSwipeRefreshLayout(activity, resId), baseLoaderWrappers);
        }

        /**
         * Enables "swipe-to-refresh" feature for the given activity.
         *
         * @param activity
         *        The Activity
         *
         * @param swipeRefreshLayout
         *        The {@code SwipeRefreshLayout}
         *
         * @param baseLoaderWrappers
         *        The {@code BaseLoaderWrapper}'s collection associated with the given activity
         */
        public static boolean register(final Activity activity, final SwipeRefreshLayout swipeRefreshLayout,
                                       final Collection<BaseLoaderWrapper<?>>    baseLoaderWrappers) {
            return register(activity, swipeRefreshLayout, baseLoaderWrappers, null);
        }

        /**
         * Enables "swipe-to-refresh" feature for the given activity.
         *
         * @param activity
         *        The Activity
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         *
         * @param baseLoaderWrappers
         *        The {@code BaseLoaderWrapper}'s collection associated with the given activity
         *
         * @param parameters
         *        The loading parameters
         */
        @SuppressWarnings("unused")
        public static boolean register(final Activity activity, @IdRes final int resId,
                                       final Collection<BaseLoaderWrapper<?>>    baseLoaderWrappers,
                                       final LoadParameters                      parameters) {
            return register(activity, findSwipeRefreshLayout(activity, resId), baseLoaderWrappers, parameters);
        }

        /**
         * Enables "swipe-to-refresh" feature for the given activity.
         *
         * @param activity
         *        The Activity
         *
         * @param swipeRefreshLayout
         *        The {@code SwipeRefreshLayout}
         *
         * @param baseLoaderWrappers
         *        The {@code BaseLoaderWrapper}'s collection associated with the given activity
         *
         * @param parameters
         *        The loading parameters
         */
        public static boolean register(final Activity activity, final SwipeRefreshLayout swipeRefreshLayout,
                                       final Collection<BaseLoaderWrapper<?>>            baseLoaderWrappers,
                                       final LoadParameters                              parameters) {
            if (baseLoaderWrappers == null) {
                CoreLogger.logError("can't register SwipeToRefresh, baseLoaderWrappers == null");
                return false;
            }
            final int size = baseLoaderWrappers.size();
            if (size != 1) {
                CoreLogger.logError("wrong BaseLoaderWrapper collection size " + size + ", expected 1");
                return false;
            }
            return register(activity, swipeRefreshLayout, baseLoaderWrappers.iterator().next(), parameters);
        }

        /**
         * Enables "swipe-to-refresh" feature for the given activity.
         *
         * @param activity
         *        The Activity
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         *
         * @param baseLoaderWrapper
         *        The {@code BaseLoaderWrapper} associated with the given activity
         *
         * @param parameters
         *        The loading parameters
         */
        @SuppressWarnings("unused")
        public static <D> boolean register(final Activity activity, @IdRes final int resId,
                                           final BaseLoaderWrapper<D>                baseLoaderWrapper,
                                           final LoadParameters                      parameters) {
            return register(activity, findSwipeRefreshLayout(activity, resId), baseLoaderWrapper, parameters);
        }

        /**
         * Enables "swipe-to-refresh" feature for the given activity.
         *
         * @param activity
         *        The Activity
         *
         * @param swipeRefreshLayout
         *        The {@code SwipeRefreshLayout}
         *
         * @param baseLoaderWrapper
         *        The {@code BaseLoaderWrapper} associated with the given activity
         *
         * @param parameters
         *        The loading parameters
         */
        public static <D> boolean register(final Activity activity, final SwipeRefreshLayout swipeRefreshLayout,
                                           final BaseLoaderWrapper<D>                        baseLoaderWrapper,
                                           final LoadParameters                              parameters) {
            //noinspection Convert2Lambda
            return register(activity, swipeRefreshLayout, baseLoaderWrapper,
                    parameters == null ? null: new Callable<LoadParameters>() {
                        @Override
                        public LoadParameters call() {
                            return parameters;
                        }
                    });
        }

        /**
         * Enables "swipe-to-refresh" feature for the given activity.
         *
         * @param activity
         *        The Activity
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         *
         * @param baseLoaderWrapper
         *        The {@code BaseLoaderWrapper} associated with the given activity
         *
         * @param parameters
         *        The loading parameters
         */
        @SuppressWarnings("unused")
        public static <D> boolean register(Activity activity, @IdRes final int resId,
                                           final BaseLoaderWrapper<D>          baseLoaderWrapper,
                                           final Callable<LoadParameters>      parameters) {
            return register(activity, findSwipeRefreshLayout(activity, resId), baseLoaderWrapper, parameters);
        }

        /**
         * Enables "swipe-to-refresh" feature for the given activity.
         *
         * @param activity
         *        The Activity
         *
         * @param swipeRefreshLayout
         *        The {@code SwipeRefreshLayout}
         *
         * @param baseLoaderWrapper
         *        The {@code BaseLoaderWrapper} associated with the given activity
         *
         * @param parameters
         *        The loading parameters
         */
        public static <D> boolean register(Activity activity, final SwipeRefreshLayout swipeRefreshLayout,
                                           final BaseLoaderWrapper<D>                  baseLoaderWrapper,
                                           final Callable<LoadParameters>              parameters) {
            if (swipeRefreshLayout == null) {
                CoreLogger.logError("can't register SwipeToRefresh, swipeRefreshLayout == null");
                return false;
            }
            if (baseLoaderWrapper == null) {
                CoreLogger.logError("can't register SwipeToRefresh, baseLoaderWrapper == null");
                return false;
            }
            if (activity == null) {
                CoreLogger.log("activity == null, current one will be used for SwipeToRefresh");
                activity = Utils.getCurrentActivity();
            }

            final OnRefreshListenerHelper<D> onRefreshListener = new OnRefreshListenerHelper<>(
                    baseLoaderWrapper, parameters);
            final SwipeToRefreshWrapper<D> swipeToRefreshWrapper = new SwipeToRefreshWrapper<>(
                    onRefreshListener, new WeakReference<>(swipeRefreshLayout)
            );
            onRefreshListener.mSwipeToRefreshWrapper = swipeToRefreshWrapper;

            ViewHelper.setTag(swipeRefreshLayout, ID_SWIPE_LAYOUT, swipeToRefreshWrapper);

            final BaseViewModel<?> baseViewModel = baseLoaderWrapper.findViewModel(activity);
            if (baseViewModel instanceof PagingViewModel)
                //noinspection Convert2Lambda
                ((PagingViewModel) baseViewModel).setOnSwipeToRefresh(new Runnable() {
                    @Override
                    public void run() {
                        stopRefreshing(swipeRefreshLayout);
                    }
                });
            return true;
        }

        private static SwipeRefreshLayout findSwipeRefreshLayout(Activity activity, @IdRes final int resId) {
            if (activity == null) activity = Utils.getCurrentActivity();

            final View swipeRefreshLayout = activity.findViewById(resId);
            if (swipeRefreshLayout == null)
                CoreLogger.logError("can't find SwipeRefreshLayout with id " +
                        CoreLogger.getResourceDescription(resId));
            else if (!(swipeRefreshLayout instanceof SwipeRefreshLayout))
                CoreLogger.logError("view with id " + CoreLogger.getResourceDescription(resId) +
                        " is not SwipeRefreshLayout but " + swipeRefreshLayout.getClass().getName());
            else
                return (SwipeRefreshLayout) swipeRefreshLayout;

            return null;
        }

        private static class OnRefreshListenerHelper<D> implements OnRefreshListener {

            private final Callable<LoadParameters>          mParameters;
            private final BaseLoaderWrapper    <D>          mBaseLoaderWrapper;
            private       SwipeToRefreshWrapper<D>          mSwipeToRefreshWrapper;

            private OnRefreshListenerHelper(@NonNull final BaseLoaderWrapper<D>     baseLoaderWrapper,
                                                     final Callable<LoadParameters> parameters) {
                mBaseLoaderWrapper      = baseLoaderWrapper;
                mParameters             = parameters;
            }

            @Override
            public void onRefresh() {
                CoreLogger.log("about to run Swipe-To-Refresh onRefresh()");

                // in case of paging
                if (mBaseLoaderWrapper.invalidateDataSource(null)) {
                    mBaseLoaderWrapper.mSwipeToRefresh = true;
                    return;
                }

                LoadParameters loadParameters = null;
                try {
                    if (mParameters != null) loadParameters = mParameters.call();
                    if (loadParameters != null)
                        CoreLogger.log("SwipeToRefresh - accepted values for LoadParameters: " + loadParameters);
                }
                catch (Exception exception) {
                    CoreLogger.log(exception);
                }

                if (loadParameters == null) {
                    loadParameters = new LoadParameters();
                    CoreLogger.log("SwipeToRefresh - accepted default values for LoadParameters: " + loadParameters);
                }

                final SwipeRefreshLayout swipeRefreshLayout = mSwipeToRefreshWrapper.get();
                if (swipeRefreshLayout == null) return;

                if (!loadParameters.getNoProgress()) swipeRefreshLayout.setRefreshing(false);

                mBaseLoaderWrapper.setSwipeToRefreshWrapper(mSwipeToRefreshWrapper);

                mBaseLoaderWrapper.start(new LoadParameters(loadParameters, true));
            }
        }

        private static Collection<View> findViews(final Activity activity) {
            final ArrayList<View> result = new ArrayList<>();

            //noinspection Convert2Lambda
            ViewHelper.findView(result, ViewHelper.getView(activity), new ViewHelper.ViewVisitor() {
                @SuppressWarnings("unused")
                @Override
                public boolean handle(final View view) {
                    return view instanceof SwipeRefreshLayout;
                }
            });

            return result;
        }

        // subject to call from weaver
        /** @exclude */ @SuppressWarnings({"JavaDoc", "unused"})
        public static void onPauseOrResume(@NonNull final Activity activity, final boolean resume) {
            for (final View view: findViews(activity)) {
                final SwipeToRefreshWrapper wrapper = (SwipeToRefreshWrapper) view.getTag(ID_SWIPE_LAYOUT);
                if (wrapper != null)
                    ((SwipeRefreshLayout) view).setOnRefreshListener(
                            resume ? wrapper.mOnRefreshListener: null);
            }
        }

        private SwipeRefreshLayout get() {
            final SwipeRefreshLayout swipeRefreshLayout = mSwipeRefreshLayout.get();
            CoreLogger.log(swipeRefreshLayout == null ? Level.ERROR: CoreLogger.getDefaultLevel(),
                    "mSwipeRefreshLayout.get(): " + swipeRefreshLayout);
            return swipeRefreshLayout;
        }

        private void stopRefreshing() {
            stopRefreshing(get());
        }

        private static void stopRefreshing(final SwipeRefreshLayout swipeRefreshLayout) {
            if (swipeRefreshLayout != null) swipeRefreshLayout.setRefreshing(false);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * The class representing data loading parameters.
     */
    public static class LoadParameters implements Parcelable {

        /** Just to init (e.g. paging ViewModel), without real data loading. */
        public  static final LoadParameters       NO_LOAD                 = new LoadParameters(true);

        private static final int                  IDX_FORCE_CACHE         = 0;
        private static final int                  IDX_NO_PROGRESS         = 1;
        private static final int                  IDX_MERGE               = 2;
        private static final int                  IDX_NO_ERRORS           = 3;
        private static final int                  IDX_SYNC                = 4;
        private static final int                  IDX_HANDLE_TIMEOUT      = 5;
        private static final int                  IDX_PULL_TO_REFRESH     = 6;
        private static final int                  IDX_NO_LOAD             = 7;
        private static final int                  ARRAY_SIZE              = 8;

        private final String                      mLoaderId;
        private final boolean                     mForceCache, mNoProgress, mMerge, mNoErrors, mSync,
                                                  mHandleTimeout, mPullToRefresh, mNoLoad;
        private final String                      mError;
        private final int                         mTimeout;

        private final static AtomicBoolean        sSafe                   = new AtomicBoolean(true);

        /** @exclude */ @SuppressWarnings("JavaDoc")
        public static final Parcelable.Creator<LoadParameters> CREATOR
                = new Parcelable.Creator<LoadParameters>() {

            @Override
            public LoadParameters createFromParcel(Parcel in) {
                return new LoadParameters(in);
            }

            @Override
            public LoadParameters[] newArray(int size) {
                return new LoadParameters[size];
            }
        };

        private LoadParameters(final Parcel in) {
            mLoaderId      = in.readString();

            final boolean[] tmp = new boolean[ARRAY_SIZE];
            in.readBooleanArray(tmp);

            mForceCache    = tmp[IDX_FORCE_CACHE    ];
            mNoProgress    = tmp[IDX_NO_PROGRESS    ];
            mMerge         = tmp[IDX_MERGE          ];
            mNoErrors      = tmp[IDX_NO_ERRORS      ];
            mSync          = tmp[IDX_SYNC           ];
            mHandleTimeout = tmp[IDX_HANDLE_TIMEOUT ];
            mPullToRefresh = tmp[IDX_PULL_TO_REFRESH];
            mNoLoad        = tmp[IDX_NO_LOAD        ];

            mError         = in.readString();
            mTimeout       = in.readInt();
        }

        /**
         * Please refer to the base method description.
         */
        @Override
        public void writeToParcel(Parcel out, int flags) {
            out.writeString(mLoaderId);

            final boolean[] tmp = new boolean[ARRAY_SIZE];

            tmp[IDX_FORCE_CACHE    ] = mForceCache;
            tmp[IDX_NO_PROGRESS    ] = mNoProgress;
            tmp[IDX_MERGE          ] = mMerge;
            tmp[IDX_NO_ERRORS      ] = mNoErrors;
            tmp[IDX_SYNC           ] = mSync;
            tmp[IDX_HANDLE_TIMEOUT ] = mHandleTimeout;
            tmp[IDX_PULL_TO_REFRESH] = mPullToRefresh;
            tmp[IDX_NO_LOAD        ] = mNoLoad;

            out.writeBooleanArray(tmp);

            out.writeString(mError);
            out.writeInt   (mTimeout);
        }

        /**
         * Please refer to the base method description.
         */
        @Override
        public int describeContents() {
            return 0;
        }

        /**
         * Initialises a newly created {@code LoadParameters} object.
         */
        public LoadParameters() {
            this(false);
        }

        private LoadParameters(final boolean noLoad) {
            this(null, null, false, false, false,
                    false, false, false, false, noLoad);
        }

        /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
        public LoadParameters(@NonNull final LoadParameters loadParameters, final boolean pullToRefresh) {
            this(loadParameters.mLoaderId, loadParameters.mTimeout, loadParameters.mForceCache,
                    loadParameters.mNoProgress, loadParameters.mMerge, loadParameters.mNoErrors,
                    loadParameters.mSync, loadParameters.mHandleTimeout, pullToRefresh,
                    loadParameters.mNoLoad);
        }

        private LoadParameters(final String  loaderId, final Integer timeout, final boolean forceCache,
                               final boolean noProgress, final boolean merge, final boolean noErrors,
                               final boolean sync, final boolean handleTimeout,
                               final boolean pullToRefresh, final boolean noLoad) {
            mLoaderId       = loaderId;
            mForceCache     = forceCache;
            mNoProgress     = noProgress;
            mMerge          = merge;
            mNoErrors       = noErrors;
            mSync           = sync;
            mHandleTimeout  = handleTimeout;
            mPullToRefresh  = pullToRefresh;
            mNoLoad         = noLoad;
            mTimeout        = Core.adjustTimeout(timeout != null ? timeout: Core.TIMEOUT_CONNECTION);

            CoreLogger.log("loader ID: " + loaderId + ", force cache: " + forceCache +
                    ", no progress: " + noProgress + ", merge: " + merge + ", no errors: " +
                    noErrors + ", sync: " + sync + ", handle timeout: " + handleTimeout +
                    ", pull-to-refresh: " + mPullToRefresh + ", no load: " + mNoLoad +
                    ", timeout (ms): " + mTimeout);

            if (mNoLoad)
                CoreLogger.log("no load == true, all other parameters doesn't matter");
            if (mForceCache && mMerge) {
                mError = "wrong combination: force cache and merge";
                reportNotSafe();
                CoreLogger.log(mNoLoad ? CoreLogger.getDefaultLevel(): Level.ERROR, mError);
            }
            else
                mError = null;
        }

        private void reportNotSafe() {
            if (!sSafe.get()) throw new LoadParametersException(mError);
        }

        /**
         * Validates the data loading parameters provided.
         *
         * @return  {@code true} if the parameters are consistent, {@code false} otherwise
         */
        @SuppressWarnings({"BooleanMethodIsAlwaysInverted", "WeakerAccess"})
        public boolean checkArguments() {
            reportNotSafe();
            return mError == null;
        }

        /**
         * Gets the loader ID.
         *
         * @return  The loader ID
         */
        @SuppressWarnings("WeakerAccess")
        public String getLoaderId() {
            return mLoaderId;
        }

        /**
         * Gets the data loading timeout.
         *
         * @return  The timeout (ms)
         */
        public int getTimeout() {
            return mTimeout;
        }

        /**
         * Gets the "force cache" flag.
         *
         * @return  {@code true} to force loading data from cache, {@code false} otherwise
         */
        public boolean getForceCache() {
            return mForceCache;
        }

        /**
         * Gets the "no progress" flag.
         *
         * @return  {@code true} to not display data loading progress, {@code false} otherwise
         */
        public boolean getNoProgress() {
            return mNoProgress;
        }

        /**
         * Gets the "merge" flag.
         *
         * @return  {@code true} to merge the newly loaded data with already existing, {@code false} otherwise
         */
        public boolean getMerge() {
            return mMerge;
        }

        /**
         * Gets the "no errors" flag.
         *
         * @return  {@code true} to not display data loading errors, {@code false} otherwise
         */
        public boolean getNoErrors() {
            return mNoErrors;
        }

        /**
         * Gets the "sync" flag.
         *
         * @return  {@code true} to load data synchronously, {@code false} otherwise
         */
        @SuppressWarnings("WeakerAccess")
        public boolean getSync() {
            return mSync;
        }

        /**
         * Gets the "handle timeout" flag.
         *
         * @return  {@code true} to handle data loading timeout, {@code false} to delegate it to loader
         */
        public boolean getHandleTimeout() {
            return mHandleTimeout;
        }

        /**
         * Gets the "pull-to-refresh" flag.
         *
         * @return  {@code true} if the data loading was triggered by "pull-to-refresh", {@code false} otherwise
         */
        @SuppressWarnings("WeakerAccess")
        public boolean getPullToRefresh() {
            return mPullToRefresh;
        }

        /**
         * Gets the "no load" flag.
         *
         * @return  {@code true} to just init loader without data loading, {@code false} otherwise
         */
        @SuppressWarnings("WeakerAccess")
        public boolean getNoLoad() {
            return mNoLoad;
        }

        /**
         * Sets safe mode: if {@code false}, the {@link LoadParametersException} will be thrown
         * in case of not consistent parameters. The default value is {@code true}.
         *
         * @param value
         *        The value to set
         *
         * @return  The previous value
         */
        @SuppressWarnings("unused")
        public static boolean setSafeMode(final boolean value) {
            return sSafe.getAndSet(value);
        }

        /**
         * Please refer to the base method description.
         */
        @NonNull
        @Override
        public String toString() {
            return String.format(Utils.getLocale(), "force cache %b, no progress %b, " +
                            "no errors %b, merge %b, sync %b, handle timeout %b, params error %s, " +
                            "loader id %s, timeout (ms) %d, pull-to-refresh %b, no load %b",
                    mForceCache, mNoProgress, mNoErrors, mMerge, mSync, mHandleTimeout, mError,
                    mLoaderId, mTimeout, mPullToRefresh, mNoLoad);
        }

        /**
         * The exception which indicates not consistent loading parameters.
         */
        @SuppressWarnings("WeakerAccess")
        public static class LoadParametersException extends RuntimeException {

            /**
             * Initialises a newly created {@code LoadParametersException} object.
             *
             * @param msg
             *        The message
             */
            public LoadParametersException(@NonNull final String msg) {
                super(msg);
            }
        }

        /**
         * Builder class for {@link LoadParameters} instances.
         */
        @SuppressWarnings("unused")
        public static class Builder {

            private String                        mLoaderId;
            private boolean                       mForceCache, mNoProgress, mMerge, mNoErrors, mSync,
                                                  mHandleTimeout;
            private final boolean                 mNoLoad;
            private Integer                       mTimeout;

            /**
             * Initialises a newly created {@code Builder} object. If {@code savedInstanceState}
             * is not null, {@link Builder#create()} returns {@link LoadParameters#NO_LOAD}.
             *
             * @param savedInstanceState
             *        Please refer to {@link Activity#onCreate(Bundle)}
             */
            public Builder(final Bundle savedInstanceState) {
                mNoLoad = savedInstanceState != null;
            }

            /**
             * Sets the loader ID.
             *
             * @param loaderId
             *        The loader ID
             *
             * @return  This {@code Builder} object to allow for chaining of calls to set methods
             */
            @SuppressWarnings({"unused", "WeakerAccess"})
            public Builder setLoaderId(final String loaderId) {
                mLoaderId       = loaderId;
                return this;
            }

            /**
             * Sets the data loading timeout.
             *
             * @param timeout
             *        The timeout (ms)
             *
             * @return  This {@code Builder} object to allow for chaining of calls to set methods
             */
            @SuppressWarnings({"unused", "WeakerAccess"})
            public Builder setTimeout(final int timeout) {
                mTimeout        = timeout;
                return this;
            }

            /**
             * Sets the "force cache" flag.
             *
             * @param forceCache
             *        {@code true} to force loading data from cache, {@code false} otherwise
             *
             * @return  This {@code Builder} object to allow for chaining of calls to set methods
             */
            @SuppressWarnings({"unused", "WeakerAccess"})
            public Builder setForceCache(final boolean forceCache) {
                mForceCache     = forceCache;
                return this;
            }

            /**
             * Sets the "no progress" flag.
             *
             * @param noProgress
             *        {@code true} to not display data loading progress, {@code false} otherwise
             *
             * @return  This {@code Builder} object to allow for chaining of calls to set methods
             */
            @SuppressWarnings({"unused", "WeakerAccess"})
            public Builder setNoProgress(final boolean noProgress) {
                mNoProgress     = noProgress;
                return this;
            }

            /**
             * Sets the "merge" flag.
             *
             * @param merge
             *        {@code true} to merge the newly loaded data with already existing, {@code false} otherwise
             *
             * @return  This {@code Builder} object to allow for chaining of calls to set methods
             */
            @SuppressWarnings({"unused", "WeakerAccess"})
            public Builder setMerge(final boolean merge) {
                mMerge          = merge;
                return this;
            }

            /**
             * Sets the "no errors" flag.
             *
             * @param noErrors
             *        {@code true} to not display data loading errors, {@code false} otherwise
             *
             * @return  This {@code Builder} object to allow for chaining of calls to set methods
             */
            @SuppressWarnings({"unused", "WeakerAccess"})
            public Builder setNoErrors(final boolean noErrors) {
                mNoErrors       = noErrors;
                return this;
            }

            /**
             * Sets the "sync" flag.
             *
             * @param sync
             *        {@code true} to load data synchronously, {@code false} otherwise
             *
             * @return  This {@code Builder} object to allow for chaining of calls to set methods
             */
            @SuppressWarnings({"unused", "WeakerAccess"})
            public Builder setSync(final boolean sync) {
                mSync           = sync;
                return this;
            }

            /**
             * Sets the "handle timeout" flag.
             *
             * @param handleTimeout
             *        {@code true} to handle data loading timeout, {@code false} to delegate it to loader
             *
             * @return  This {@code Builder} object to allow for chaining of calls to set methods
             */
            @SuppressWarnings({"unused", "WeakerAccess"})
            public Builder setHandleTimeout(final boolean handleTimeout) {
                mHandleTimeout  = handleTimeout;
                return this;
            }

            /**
             * Returns the {@link LoadParameters} with the arguments supplied to this builder.
             *
             * @return  The {@code LoadParameters} instance
             */
            @SuppressWarnings({"WeakerAccess", "unused"})
            public LoadParameters create() {
                return mNoLoad ? LoadParameters.NO_LOAD: new LoadParameters(mLoaderId, mTimeout,
                        mForceCache, mNoProgress, mMerge, mNoErrors, mSync, mHandleTimeout,
                        false, false);
            }
        }
    }
}
