/*
 * Copyright (C) 2015-2018 akha, a.k.a. Alexander Kharitonov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package akha.yakhont.loader.wrapper;

import akha.yakhont.Core;
import akha.yakhont.Core.ConfigurableLoader;
import akha.yakhont.Core.Utils;
import akha.yakhont.CoreLogger;
import akha.yakhont.CoreLogger.Level;
import akha.yakhont.fragment.WorkerFragment;
import akha.yakhont.loader.BaseLoader;
import akha.yakhont.loader.BaseLoader.ProgressWrapper;
import akha.yakhont.loader.BaseResponse.LoadParameters;
import akha.yakhont.loader.CacheLoader;
import akha.yakhont.loader.wrapper.BaseResponseLoaderWrapper.CoreLoad;

import android.annotation.TargetApi;
import android.app.Fragment;
import android.app.LoaderManager;
import android.content.Loader;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.CallSuper;
import android.support.annotation.IdRes;
import android.support.annotation.NonNull;
import android.support.annotation.RequiresApi;
import android.support.annotation.Size;
import android.support.annotation.WorkerThread;
import android.support.v4.widget.SwipeRefreshLayout;
import android.view.View;

import java.lang.ref.WeakReference;
import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * The <code>BaseLoaderWrapper</code> class is a wrapper for {@link LoaderManager} and {@link Loader} instances associated with it.
 * It's designed to be a root class for standalone, independent, self-sufficient data loading components
 * (hiding low-level implementation details and <code>LoaderManager</code>'s related boilerplate code).
 * Most implementations should not use <code>BaseLoaderWrapper</code> directly, but instead utilise
 * {@link akha.yakhont.technology.retrofit.RetrofitLoaderWrapper}
 * or {@link akha.yakhont.technology.retrofit.RetrofitLoaderWrapper.RetrofitLoaderBuilder}.
 *
 * @param <D>
 *        The type of data
 *
 * @see BaseResponseLoaderWrapper
 *
 * @author akha
 */
@TargetApi(Build.VERSION_CODES.HONEYCOMB)                       //YakhontPreprocessor:removeInFlavor
@RequiresApi(api = Build.VERSION_CODES.HONEYCOMB)               //YakhontPreprocessor:removeInFlavor
public abstract class BaseLoaderWrapper<D> implements LoaderManager.LoaderCallbacks<D> {

    private static final String                             ARG_FORCE_CACHE             = "force_cache";
    private static final String                             ARG_NO_PROGRESS             = "no_progress";
    private static final String                             ARG_NO_ERRORS               = "no_errors";
    private static final String                             ARG_MERGE                   = "merge";
    private static final String                             ARG_CONFIGURABLE            = "configurable";

    private static final String                             FORMAT_INFO_ID              = "id = %d";
    private static final String                             FORMAT_INFO                 = "BaseLoaderWrapper: %s";

    private final WeakReference<Fragment>                   mFragment;

    private final int                                       mLoaderId;
    private final boolean                                   mLoaderIdAutoGenerated;

    private SwipeRefreshWrapper                             mSwipeRefreshWrapper;
    private ProgressWrapper                                 mProgress;

    private CountDownLatch                                  mCountDownLatch;
    private D                                               mData;
    private final AtomicBoolean                             mLoading                    = new AtomicBoolean();

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected final AtomicBoolean                           mKeepLoaders                = new AtomicBoolean();
    private   final Set<Integer>                            mIdsToDestroy               = Utils.newSet();

    private static final Random                             sRandom                     = new Random();

    private LoaderManager.LoaderCallbacks<D>                mLoaderCallbacks;
    private LoaderFactory<D>                                mLoaderFactory;

    private Type                                            mType;

    /**
     * The API to create new {@code Loader} instances.
     *
     * @param <D>
     *        The type of data in the loader created
     */
    public interface LoaderFactory<D> {

        /**
         * Returns a new {@code Loader} instance.
         *
         * @param merge
         *        {@code true} to merge the newly loaded data with already existing, {@code false} otherwise
         *
         * @return  The {@code Loader} instance
         */
        Loader<D> getLoader(boolean merge);
    }

    /**
     * Initialises a newly created {@code BaseLoaderWrapper} object.
     *
     * @param fragment
     *        The fragment
     *
     * @param loaderId
     *        The loader ID
     */
    @SuppressWarnings("WeakerAccess")
    public BaseLoaderWrapper(@NonNull final Fragment fragment, final Integer loaderId) {
        this(fragment, loaderId, loaderId == null);
    }

    /** @exclude */ @SuppressWarnings("JavaDoc")
    protected BaseLoaderWrapper(@NonNull final Fragment fragment, final Integer loaderId,
                                final boolean loaderIdAutoGenerated) {
        mFragment                   = new WeakReference<>(getFragment(fragment));
        mLoaderId                   = loaderId == null ? generateLoaderId(): loaderId;
        mLoaderIdAutoGenerated      = loaderIdAutoGenerated;

        if (mLoaderIdAutoGenerated)
            CoreLogger.log("auto generated id " + mLoaderId);
    }

    /**
     * Returns the type of data (if was set).
     *
     * @return  The data type
     *
     * @see #setType(Type) setType()
     */
    @SuppressWarnings({"WeakerAccess", "unused"})
    public Type getType() {
        return mType;
    }

    /**
     * Sets the type of data.
     *
     * @param type
     *        The data type
     *
     * @see BaseLoader.CoreLoadExtendedBuilder#setType
     */
    @SuppressWarnings("WeakerAccess")
    public void setType(final Type type) {
        mType = type;
    }

    /**
     * Sets "swipe refresh" component.
     *
     * @param swipeRefreshWrapper
     *        The component
     *
     * @return  This {@code BaseLoaderWrapper} object
     */
    @NonNull
    @SuppressWarnings("UnusedReturnValue")
    public BaseLoaderWrapper<D> setSwipeRefreshWrapper(final SwipeRefreshWrapper swipeRefreshWrapper) {
        mSwipeRefreshWrapper        = swipeRefreshWrapper;
        return this;
    }

    /**
     * Sets component to display progress.
     *
     * @param progressWrapper
     *        The progress component
     *
     * @return  This {@code BaseLoaderWrapper} object
     */
    @NonNull
    @SuppressWarnings({"UnusedReturnValue", "SameParameterValue"})
    public BaseLoaderWrapper<D> setProgress(final ProgressWrapper progressWrapper) {
        mProgress                   = progressWrapper;
        return this;
    }

    /**
     * Sets loader factory.
     *
     * @param loaderFactory
     *        The factory
     *
     * @return  This {@code BaseLoaderWrapper} object
     */
    @NonNull
    @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
    public BaseLoaderWrapper<D> setLoaderFactory(@NonNull final LoaderFactory<D> loaderFactory) {
        mLoaderFactory              = loaderFactory;
        return this;
    }

    /**
     * Returns the loader factory.
     *
     * @return  The loader factory
     */
    @SuppressWarnings("WeakerAccess")
    public LoaderFactory<D> geLoaderFactory() {
        return mLoaderFactory;
    }

    /**
     * Sets loader callbacks.
     *
     * @param loaderCallbacks
     *        The callbacks
     *
     * @return  This {@code BaseLoaderWrapper} object
     */
    @NonNull
    @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
    public BaseLoaderWrapper<D> setLoaderCallbacks(final LoaderManager.LoaderCallbacks<D> loaderCallbacks) {
        mLoaderCallbacks            = loaderCallbacks;
        return this;
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "unused"})
    public boolean setKeepLoaders(final boolean value) {
        return mKeepLoaders.getAndSet(value);
    }

    /**
     * Returns the loader callbacks.
     *
     * @return  The loader callbacks
     */
    @SuppressWarnings("unused")
    public LoaderManager.LoaderCallbacks<D> geLoaderCallbacks() {
        return mLoaderCallbacks;
    }

    private static int generateLoaderId() {
        return sRandom.nextInt(Integer.MAX_VALUE);
    }

    /**
     * Returns the loader ID.
     *
     * @return  The loader ID
     */
    public int getLoaderId() {
        return mLoaderId;
    }

    /**
     * Indicates whether the loader ID was auto generated or not.
     *
     * @return  {@code true} if the loader ID was auto generated, {@code false} otherwise
     */
    @SuppressWarnings({"WeakerAccess", "unused"})
    public boolean isAutoGeneratedId() {
        return mLoaderIdAutoGenerated;
    }

    private static Fragment getFragment(@NonNull final Fragment fragment) {
        final WorkerFragment workerFragment = WorkerFragment.findInstance(fragment);
        if (workerFragment != null) return workerFragment;

        CoreLogger.logError("WorkerFragment not found; argument fragment will be used, so some functionality will be lost");
        return fragment;
    }

    /**
     * Returns fragment this {@code BaseLoaderWrapper} object is associated with.
     *
     * @return  The fragment
     */
    @SuppressWarnings("WeakerAccess")
    public Fragment getFragment() {
        final Fragment fragment = mFragment.get();
        if (fragment == null)
            CoreLogger.logError("fragment == null");
        return fragment;
    }

    private LoaderManager getLoaderManager() {
        final Fragment fragment = getFragment();
        if (fragment == null) return null;

        final LoaderManager loaderManager = fragment.getLoaderManager();
        if (loaderManager == null)
            CoreLogger.logError("loader manager == null");
        return loaderManager;
    }

    /**
     * Tries to find similar loader (based on ID) in the given collection.
     *
     * @param loaders
     *        The loaders collection
     *
     * @return  The {@code BaseLoaderWrapper} object or null (if not found)
     */
    public BaseLoaderWrapper findLoader(final Collection<BaseLoaderWrapper> loaders) {
        for (final BaseLoaderWrapper baseLoaderWrapper: loaders) {
            if (baseLoaderWrapper.mLoaderId == mLoaderId) {
                CoreLogger.log("found loader with id " + mLoaderId);
                return baseLoaderWrapper;
            }
        }
        CoreLogger.log("can't find loader with id " + mLoaderId);
        return null;
    }

    /**
     * Please refer to the base method description.
     */
    @Override
    public String toString() {
        return String.format(CoreLogger.getLocale(), FORMAT_INFO, toString(mLoaderId));
    }

    private String toString(final int id) {
        final LoaderManager loaderManager = getLoaderManager();
        if (loaderManager != null) {
            final Loader loader = loaderManager.getLoader(id);
            if (loader != null) return loader.toString();
        }
        return String.format(CoreLogger.getLocale(), FORMAT_INFO_ID, id);
    }

    /**
     * Destroys loaders.
     *
     * @param loaderManager
     *        The Loader Manager
     *
     * @param loaders
     *        The loaders to destroy
     *
     * @param forceDestroy
     *        If {@code true}, forces to destroy all (including already started) loaders
     *
     * @yakhont.see BaseLoader#destroyLoaders
     */
    @SuppressWarnings("UnusedReturnValue")
    public static boolean destroyLoaders(final LoaderManager loaderManager,
                                         final Collection<BaseLoaderWrapper> loaders,
                                         final boolean forceDestroy) {
        if (!checkEmpty(Level.DEBUG, loaders)) return false;

        CoreLogger.logWarning("about to destroy loaders in " + loaders);

        final Collection<Integer> loadersIds = new HashSet<>();
        for (final BaseLoaderWrapper loader: loaders)
            loadersIds.add(loader.getLoaderId());

        BaseLoader.destroyLoaders(loaderManager, loadersIds, forceDestroy);
        return true;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Starts data loading.
     *
     * @param loaders
     *        The loaders
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if at least one loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    public static boolean start(final Collection<BaseLoaderWrapper> loaders,
                                final LoadParameters parameters) {
        if (!checkEmpty(Level.ERROR, loaders)) return false;

        if (parameters == null || parameters.getLoaderId() == null) {
            boolean result = true;
            for (final BaseLoaderWrapper loader: loaders)
                if (!loader.start(parameters)) result = false;
            return result;
        }
        else {
            final int id = parameters.getLoaderId();
            for (final BaseLoaderWrapper loader: loaders)
                if (id == loader.getLoaderId())
                    return loader.start(parameters);
            CoreLogger.logError("invalid loader ID: " + id);
            return false;
        }
    }

    /**
     * Starts data loading.
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    public boolean start(final LoadParameters parameters) {
        final boolean result = startHelper(parameters);
        CoreLogger.log(result ? Level.DEBUG: Level.ERROR, "start loading result: " + result);
        return result;
    }

    private boolean startHelper(final LoadParameters parameters) {
        if (parameters == null) {
            final Bundle bundle = new Bundle();
            bundle.putBoolean(ARG_CONFIGURABLE, false);

            return start(bundle);
        }
        if (parameters.getSync())
            return startSync(parameters) != null;

        if (!parameters.checkArguments()) return false;

        final Integer id = parameters.getLoaderId();
        if (id != null && id != mLoaderId) {
            CoreLogger.logError("invalid loader ID: " + id + " (required " + mLoaderId + " or null)");
            return false;
        }

        final Bundle bundle = new Bundle();
        bundle.putBoolean(ARG_CONFIGURABLE,     true);
        bundle.putBoolean(ARG_FORCE_CACHE,      parameters.getForceCache());
        bundle.putBoolean(ARG_NO_PROGRESS,      parameters.getNoProgress());
        bundle.putBoolean(ARG_NO_ERRORS,        parameters.getNoErrors());
        bundle.putBoolean(ARG_MERGE,            parameters.getMerge());

        return start(bundle);
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    public boolean start(final Bundle bundle) {
        mData     = null;
        mProgress = null;

        final Loader<D> loader = initOrRestart(bundle, false, mKeepLoaders.get() ? null: false);
        final boolean result = loader != null;
        if (result) {
            mLoading.set(true);
            CoreLogger.log("started loader " + loader);
        }
        return result;
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "UnusedReturnValue"})
    public boolean restoreCallbacks() {
        final Loader<D> loader = initOrRestart(null, true, true);
        final boolean result = loader != null;
        if (result)
            CoreLogger.log("restored callbacks for loader " + loader);
        return result;
    }

    private Loader<D> initOrRestart(final Bundle bundle, final boolean init, final Boolean shouldExist) {
        final LoaderManager loaderManager = getLoaderManager();
        if (loaderManager == null) return null;

        CoreLogger.log("bundle " + bundle);

        if (shouldExist != null) {
            final Loader<D> loader = loaderManager.getLoader(mLoaderId);
            if (shouldExist && loader == null)
                CoreLogger.logError("can not find loader with id " + mLoaderId);
            if (!shouldExist && loader != null)
                CoreLogger.logError("loader with id " + mLoaderId + " already exists");
        }

        return init ? loaderManager.initLoader   (mLoaderId, bundle, this):
                      loaderManager.restartLoader(mLoaderId, bundle, this);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Please refer to the base method description.
     */
    @CallSuper
    @Override
    public Loader<D> onCreateLoader(int id, Bundle args) {
        CoreLogger.log("mLoaderCallbacks: " + mLoaderCallbacks);
        if (mLoaderCallbacks != null) {

            final Loader<D> loader = mLoaderCallbacks.onCreateLoader(id, args);
            CoreLogger.log("loader: " + loader);

            if (loader != null) return loader;
        }
        return createLoader(id, args);
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    protected Loader<D> createLoader(@SuppressWarnings("unused") final int id, final Bundle args) {
        final Loader<D> loader = mLoaderFactory.getLoader(args.getBoolean(ARG_MERGE));
        if (!args.getBoolean(ARG_CONFIGURABLE)) return loader;

        final boolean noProgress = args.getBoolean(ARG_NO_PROGRESS);
        final boolean noErrors   = args.getBoolean(ARG_NO_ERRORS);

        if (loader instanceof ConfigurableLoader) {
            ((ConfigurableLoader) loader).setForceCache(args.getBoolean(ARG_FORCE_CACHE));
            ((ConfigurableLoader) loader).setNoProgress(noProgress);
        }
        else {
            if (loader instanceof CacheLoader)
                ((CacheLoader) loader).setForceCache(args.getBoolean(ARG_FORCE_CACHE));
            if (loader instanceof BaseLoader)
                ((BaseLoader)  loader).setProgress(new ProgressWrapper(mFragment,
                        noProgress, noErrors));
        }

        if (!(loader instanceof BaseLoader)) {
            mProgress = new ProgressWrapper(mFragment, noProgress, noErrors);
            mProgress.doProgress(true, null);
        }

        return loader;
    }

    /**
     * Please refer to the base method description.
     */
    @CallSuper
    @Override
    public void onLoadFinished(Loader<D> loader, D data) {
        mLoading.set(false);

        if (CoreLogger.isFullInfo()) {
            CoreLogger.log("loader: " + loader);
            CoreLogger.log(data.toString());
        }
        mData = data;

        handleSync();
        setRefreshing();

        if (mProgress != null) mProgress.doProgress(false, null);
        mProgress = null;

        if (mLoaderCallbacks != null) mLoaderCallbacks.onLoadFinished(loader, data);

        if (mKeepLoaders.get()) return;
        final int id = loader.getId();
        mIdsToDestroy.add(id);

        if (!BaseLoader.destroyLoader(getLoaderManager(), id, true))
            mIdsToDestroy.remove(id);
    }

    /**
     * Please refer to the base method description.
     */
    @CallSuper
    @Override
    public void onLoaderReset(Loader<D> loader) {
        onLoaderResetHelper(loader);
    }

    /** @exclude */ @SuppressWarnings({"JavaDoc", "WeakerAccess"})
    @CallSuper
    protected boolean onLoaderResetHelper(@NonNull final Loader<D> loader) {
        final Integer id = loader.getId();
        if (mIdsToDestroy.contains(id)) {
            mIdsToDestroy.remove(id);
            return false;
        }

        mLoading.set(false);

        CoreLogger.logWarning("reset loader: " + loader);

        handleSync();
        setRefreshing();

        if (mLoaderCallbacks != null) mLoaderCallbacks.onLoaderReset(loader);
        return true;
    }

    /**
     * Indicates whether the loader is busy with data loading or not.
     *
     * @return  {@code true} if the loader is busy, {@code false} otherwise
     */
    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    public boolean isLoading() {
        return mLoading.get();
    }

    private void setRefreshing() {
        if (mSwipeRefreshWrapper != null) mSwipeRefreshWrapper.setRefreshing();
    }

    private void handleSync() {
        if (mCountDownLatch == null) return;

        mCountDownLatch.countDown();
        mCountDownLatch = null;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Starts data loading in synchronous mode.
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    @WorkerThread
    public D startSync(final LoadParameters parameters) {
        final boolean result = startSync(Arrays.asList(new BaseLoaderWrapper[] {this}), parameters);
        return result ? mData: null;
    }

    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    private static boolean checkEmpty(@NonNull final Level level, final Collection<BaseLoaderWrapper> loaders) {
        final boolean empty = loaders == null || loaders.isEmpty();
        if (empty)
            CoreLogger.log(level, "no loaders in collection");
        else
            CoreLogger.log("loaders list size: " + loaders.size());
        return !empty;
    }

    /**
     * Starts data loading in synchronous mode.
     *
     * @param loaders
     *        The loaders
     *
     * @param parameters
     *        The loading parameters
     *
     * @return  {@code false} if at least one loader failed to start, {@code true} otherwise
     */
    @SuppressWarnings("WeakerAccess")
    @WorkerThread
    public static boolean startSync(final Collection<BaseLoaderWrapper> loaders,
                                    final LoadParameters parameters) {
        if (parameters != null && !parameters.checkArguments()) return false;

        if (parameters != null && !parameters.getSync()) {
            CoreLogger.logError("invalid parameter sync: false");
            return false;
        }
        if (Utils.isCurrentThreadMain()) {
            CoreLogger.logError("not allowed to run from the main thread");
            return false;
        }

        if (!checkEmpty(Level.ERROR, loaders)) return false;

        if (parameters != null && parameters.getLoaderId() != null) {
            final int id = parameters.getLoaderId();
            boolean found = false;
            for (final BaseLoaderWrapper loader: loaders)
                if (id == loader.mLoaderId) {
                    found = true;
                    break;
                }
            if (!found) {
                CoreLogger.logError("no such loader ID: " + id);
                return false;
            }
        }

        final CountDownLatch countDownLatch = new CountDownLatch(
                parameters != null && parameters.getLoaderId() != null ? 1: loaders.size());

        for (final BaseLoaderWrapper loader: loaders)
            if (checkId(parameters, loader.mLoaderId))
                loader.setCountDownLatch(countDownLatch);

        final boolean[] result = new boolean[] {true};
        //noinspection Convert2Lambda
        Utils.runInBackground(new Runnable() {
            @Override
            public void run() {
                for (final BaseLoaderWrapper loader: loaders)
                    if (checkId(parameters, loader.mLoaderId))
                        if (!loader.start(parameters)) result[0] = false;
            }
        });

        await(countDownLatch);

        for (final BaseLoaderWrapper loader: loaders)
            if (checkId(parameters, loader.mLoaderId))
                loader.setCountDownLatch(null);

        CoreLogger.log("completed");
        return result[0];
    }

    private static boolean checkId(final LoadParameters parameters, final int id) {
        if (parameters == null) return true;
        final Integer idParam = parameters.getLoaderId();
        return idParam == null || idParam == id;
    }

    private static void await(final CountDownLatch countDownLatch) {
        if (countDownLatch == null) return;
        try {
            countDownLatch.await();
        }
        catch (InterruptedException e) {
            CoreLogger.log("interrupted", e);
        }
    }

    @SuppressWarnings("UnusedReturnValue")
    private BaseLoaderWrapper<D> setCountDownLatch(final CountDownLatch countDownLatch) {
        mCountDownLatch = countDownLatch;
        return this;
    }

    /**
     * Returns the loaded data.
     *
     * @return  The loaded data
     */
    @SuppressWarnings("unused")
    public D getResult() {
        return mData;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * The <code>SwipeRefreshWrapper</code> class is intended to support "swipe refresh" feature. To enable swipe refresh,
     * fragment should contain {@link SwipeRefreshLayout} and register it via one of the methods provided
     * (for example, {@link #register(Fragment, int, boolean) register()}). For example:
     *
     * <p><pre style="background-color: silver; border: thin solid black;">
     * public class YourFragment extends Fragment {
     *
     *     &#064;Override
     *     public void onActivityCreated(Bundle savedInstanceState) {
     *         super.onActivityCreated(savedInstanceState);
     *         ...
     *         SwipeRefreshWrapper.register(this, R.id.swipeContainer);
     *     }
     * }
     * </pre>
     *
     * And in the layout XML:
     *
     * <p><pre style="background-color: silver; border: thin solid black;">
     * &lt;android.support.v4.widget.SwipeRefreshLayout
     *     android:id="&#064;+id/swipeContainer"
     *     ... &gt;
     *
     *     &lt;ListView ... /&gt;
     *
     * &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;
     * </pre>
     *
     * @see SwipeRefreshLayout
     */
    @SuppressWarnings("WeakerAccess")
    public static class SwipeRefreshWrapper {

        private static final Map<Fragment, Collection<FragmentData>>
                                                            sFragmentData               = Utils.newWeakMap();
        private final WeakReference<SwipeRefreshLayout>     mSwipeRefreshLayout;

        /**
         * Initialises a newly created {@code SwipeRefreshWrapper} object.
         *
         * @param layout
         *        The {@code SwipeRefreshLayout}
         */
        protected SwipeRefreshWrapper(@NonNull final SwipeRefreshLayout layout) {
            mSwipeRefreshLayout = new WeakReference<>(layout);
        }

        private void setRefreshing() {
            CoreLogger.log("mSwipeRefreshLayout.get(): " + mSwipeRefreshLayout.get());

            if (mSwipeRefreshLayout.get() != null) mSwipeRefreshLayout.get().setRefreshing(false);
        }

        /**
         * Enables "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         */
        @SuppressWarnings("unused")
        public static void register(@NonNull final Fragment fragment,
                                    final @IdRes int resId) {
            register(fragment, resId, false);
        }

        /**
         * Enables "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         *
         * @param noErrors
         *        Whether or not the view should show loading errors
         */
        @SuppressWarnings("unused")
        public static void register(@NonNull final Fragment fragment,
                                    final @IdRes int resId, final boolean noErrors) {
            register(fragment, new int[] {resId}, noErrors);
        }

        /**
         * Enables "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         *
         * @param resIds
         *        The list of {@code SwipeRefreshLayout}'s resource IDs
         *
         * @param noErrors
         *        Whether or not the view should show loading errors
         */
        public static void register(@NonNull final Fragment fragment,
                                    @NonNull @Size(min = 1) final @IdRes int[] resIds,
                                    final boolean noErrors) {
            final FragmentData[] fragmentData = new FragmentData[resIds.length];
            for (int i = 0; i < resIds.length; i++)
                fragmentData[i] = new FragmentData(fragment, resIds[i],
                        new LoadParameters(null, false, false, false, noErrors, false), null);
            register(fragment, Arrays.asList(fragmentData));
        }

        /**
         * Enables "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         *
         * @param data
         *        The data to register
         */
        @SuppressWarnings("unused")
        public static void register(@NonNull final Fragment fragment, @NonNull final FragmentData data) {
            register(fragment, Collections.singletonList(data));
        }

        /**
         * Enables "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         *
         * @param data
         *        The data to register
         */
        public static void register(@NonNull final Fragment fragment, @NonNull @Size(min = 1) final Collection<FragmentData> data) {
            CoreLogger.log("about to register: " + Arrays.deepToString(data.toArray()));
            sFragmentData.put(fragment, data);
        }

        private static void onPauseOrResume(@NonNull final Fragment fragment, final @IdRes int resId, final boolean resume) {
            final Collection<FragmentData> fragmentData = sFragmentData.get(fragment);
            if (fragmentData == null) {
                if (resId != Core.NOT_VALID_RES_ID) CoreLogger.logError("data not found for fragment " + fragment);
                return;
            }

            CoreLogger.log("subject to call by weaver");
            for (final FragmentData data: fragmentData) {
                if (resId != Core.NOT_VALID_RES_ID && resId != data.mResId) continue;

                if (resume)
                    onResume(fragment, data.mView, data.mResId);
                else
                    onPause(data.mView, data.mResId);
            }
        }

        /**
         * Called by the Yakhont Weaver to support "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         */
        @SuppressWarnings("unused")
        public static void onResume(@NonNull final Fragment fragment) {
            onPauseOrResume(fragment, Core.NOT_VALID_RES_ID, true);
        }

        /**
         * Should be called from {@link Fragment#onResume()} to support "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         */
        @SuppressWarnings("unused")
        public static void onResume(@NonNull final Fragment fragment, final @IdRes int resId) {
            onPauseOrResume(fragment, resId, true);
        }

        /**
         * Should be called from {@link Fragment#onResume()} to support "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         *
         * @param view
         *        The view which contains {@code SwipeRefreshLayout}
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         */
        @SuppressWarnings("SameParameterValue")
        public static void onResume(@NonNull final Fragment fragment, final View view, final @IdRes int resId) {
            final SwipeRefreshLayout swipeRefreshLayout = getSwipeContainer(view, resId);
            if (swipeRefreshLayout == null) return;

            //noinspection Convert2Lambda
            swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
                @Override
                public void onRefresh() {
                    final Collection<FragmentData> fragmentData = sFragmentData.get(fragment);
                    if (fragmentData == null) {
                        CoreLogger.logError("data not found for fragment " + fragment);
                        return;
                    }

                    final FragmentData data = getData(fragmentData, resId);
                    if (data == null) {
                        CoreLogger.logError("data not found for resId " + resId);
                        return;
                    }
                    final Integer id = data.mLoadParameters.getLoaderId();

                    if (!data.mLoadParameters.getNoProgress()) swipeRefreshLayout.setRefreshing(false);

                    final CoreLoad coreLoad = BaseLoader.getCoreLoad(fragment);
                    if (coreLoad == null) return;

                    coreLoad.setGoBackOnLoadingCanceled(false);

                    if (data.mRunnable != null) data.mRunnable.run();

                    boolean started = false;
                    for (final BaseLoaderWrapper loader: coreLoad.getLoaders()) {
                        if (id != null && id != loader.getLoaderId()) continue;

                        loader.setSwipeRefreshWrapper(new SwipeRefreshWrapper(swipeRefreshLayout));
                        loader.start(data.mLoadParameters);

                        started = true;
                    }
                    if (started) return;

                    if (id != null)
                        CoreLogger.logError("not found loader with id " + id);
                    else
                        CoreLogger.logWarning("no loaders to start");
                }
            });
        }

        private static FragmentData getData(@NonNull final Collection<FragmentData> fragmentData, final @IdRes int resId) {
            for (final FragmentData data: fragmentData)
                if (resId == data.mResId) return data;
            return null;
        }

        /**
         * Called by the Yakhont Weaver to support "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         */
        @SuppressWarnings("unused")
        public static void onPause(@NonNull final Fragment fragment) {
            onPauseOrResume(fragment, Core.NOT_VALID_RES_ID, false);
        }

        /**
         * Should be called from {@link Fragment#onPause()} to support "swipe refresh" feature for the given fragment.
         *
         * @param fragment
         *        The fragment
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         */
        @SuppressWarnings("unused")
        public static void onPause(@NonNull final Fragment fragment, final @IdRes int resId) {
            onPauseOrResume(fragment, resId, false);
        }

        /**
         * Should be called from {@link Fragment#onPause()} to support "swipe refresh" feature for the given fragment.
         *
         * @param view
         *        The view which contains {@code SwipeRefreshLayout}
         *
         * @param resId
         *        The resource ID of the {@code SwipeRefreshLayout}
         */
        public static void onPause(final View view, final @IdRes int resId) {
            final SwipeRefreshLayout swipeRefreshLayout = getSwipeContainer(view, resId);
            if (swipeRefreshLayout == null) return;

            swipeRefreshLayout.setOnRefreshListener(null);
        }

        private static SwipeRefreshLayout getSwipeContainer(final View view, final @IdRes int resId) {
            if (view == null) {
                CoreLogger.logError("view == null");
                return null;
            }

            final View swipeRefreshLayout = view.findViewById(resId);
            if (swipeRefreshLayout == null) {
                CoreLogger.logError("SwipeRefreshLayout == null, id " + resId);
                return null;
            }

            if (!(swipeRefreshLayout instanceof SwipeRefreshLayout)) {
                CoreLogger.logError("view with id " + resId + " is not SwipeRefreshLayout but " +
                        swipeRefreshLayout.getClass().getName());
                return null;
            }

            return (SwipeRefreshLayout) swipeRefreshLayout;
        }

        /**
         * The <code>FragmentData</code> class is a container to store data required to support "swipe refresh" feature.
         */
        public static class FragmentData {

            /** @exclude */ @SuppressWarnings("JavaDoc")
            public final View                               mView;
            /** @exclude */ @SuppressWarnings("JavaDoc")
            public final @IdRes int                         mResId;
            /** @exclude */ @SuppressWarnings("JavaDoc")
            public final LoadParameters                     mLoadParameters;
            /** @exclude */ @SuppressWarnings("JavaDoc")
            public final Runnable                           mRunnable;

            /**
             * Initialises a newly created {@code FragmentData} object.
             *
             * @param fragment
             *        The fragment
             *
             * @param resId
             *        The resource ID of the {@code SwipeRefreshLayout}
             *
             * @param loadParameters
             *        The LoadParameters
             *
             * @param runnable
             *        The {@code Runnable} to run before loading will be started
             */
            @SuppressWarnings("SameParameterValue")
            public FragmentData(@NonNull final Fragment fragment, final @IdRes int resId,
                                @NonNull final LoadParameters loadParameters, final Runnable runnable) {
                this(fragment.getView(), resId, loadParameters, runnable);
            }

            /**
             * Initialises a newly created {@code FragmentData} object.
             *
             * @param view
             *        The view which contains {@code SwipeRefreshLayout}
             *
             * @param resId
             *        The resource ID of the {@code SwipeRefreshLayout}
             *
             * @param loadParameters
             *        The LoadParameters
             *
             * @param runnable
             *        The {@code Runnable} to run before loading will be started
             */
            @SuppressWarnings("SameParameterValue")
            public FragmentData(final View view, final @IdRes int resId,
                                @NonNull final LoadParameters loadParameters, final Runnable runnable) {
                mView                       = view;
                mResId                      = resId;
                mLoadParameters             = loadParameters;
                mRunnable                   = runnable;
            }

            /**
             * Please refer to the base method description.
             */
            @Override
            public String toString() {
                return String.format(CoreLogger.getLocale(), "resId %d, parameters %s",
                        mResId, mLoadParameters == null ? "null": mLoadParameters.toString());
            }
        }
    }
}
